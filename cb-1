function selectRandomElements(arr, count, previousSelection = null) {
    let theFinalSelection = [];
    let theSelectionCounter = count;
    let theNextSelection;
    let thePreviousSelection = previousSelection;
    let defaultCaseCounter = 0;
    let categoryRequired;
    let nameFilter;
    let isSuitable = false;
    let possibleExits = [];
    let adjustedExit;

    function pickRandomTrick(trickCategory = null, nameFilter = null) {
        let filteredArr = arr;

        if (trickCategory) {
            filteredArr = arr.filter(trick => trick.ca.startsWith(trickCategory) || trick.c1 === trickCategory || trick.p1 === trickCategory);
            if (nameFilter) {
                let nameFilteredArr = filteredArr.filter(trick => trick.na.includes(nameFilter));

                if (nameFilteredArr.length === 0) {
                    console.log("No tricks found with name filter:", nameFilter, "in the requested category:", trickCategory, ". Broadening search.");
                } else {
                    filteredArr = nameFilteredArr;
                }
            }
        }

        if (filteredArr.length === 0) {
            console.log("No tricks found in the requested category:", trickCategory, "with filter type:", filterType);
            return null;
        }

        let randomIndex = Math.floor(Math.random() * filteredArr.length);
        let selectedTrick = {...filteredArr[randomIndex]};

        if (selectedTrick.ca.length === 2) {
            selectedTrick.cb = selectedTrick.ca; // storing the 2-letter 'ca' separately for future reference
            console.log('selectedTrick.cb created:',selectedTrick.cb);
            if (trickCategory) {
            selectedTrick.ca = trickCategory;
            console.log('requested trickCategory assigned to selectedTrick.ca:',selectedTrick.ca);
        } else {
            selectedTrick.ca = selectedTrick.ca.charAt(0);
            console.log('trickCategory is null so selectedTrick.ca created explicitly:',selectedTrick.ca);
          }
        }

        console.log('Randomly selected trick:', selectedTrick.na, 'category:', selectedTrick.ca);
        return selectedTrick;
    }  

    function removeTheLastOpen(skill) {
        let parts = skill.sk.split(" > ");
        if (parts.length > 1) {  
            skill.sk = parts.slice(0, 1).join(" > ") + " >";
          }
        }

    function pickRandomOption(theOptions) {
        let defaultOpen = {
            "na": "Open",
            "sk": "> Open >",
            "no": "O,",
            "ca": "C",
            "c1": "Foundational"
        };
    if (Array.isArray(theOptions) && theOptions.length > 0) {
        let randomIndex = Math.floor(Math.random() * theOptions.length);
        let selectedOption = theOptions[randomIndex];
        console.log('Randomly selected option:', selectedOption);
        return selectedOption;
    } else {
        console.log('No options available, using the default...');
        return defaultOpen;
        }
    }    
    

    // SKILL EXIT MODIFIER FUNCTIONS
    let isValidEntry = false; // used for intra-case functions only
    let isValidExit = false;
    let isNeeded = false; // used for doWeNeedBWTurnNext function only
    let isValidComboExit = false; // used for intra-case functions only

    function checkCrossExit() {
        isValidExit = false;

        if (theNextSelection.sk.endsWith('> Cross >')) {
            console.log('C-F1-1: ',theNextSelection.na,' ends with a Cross');
            isValidExit = true;
        } else if (theNextSelection.na.includes('Caboose') || theNextSelection.na.includes('to Caboose')) {
            console.log('C-F1-2-1: ',theNextSelection.na, ' is a ~Caboose~.');
            if (theFinalSelection.length < theSelectionCounter) {
            theFinalSelection.push(theNextSelection);
            let exitBackwards = Math.random() < 0.5;
            let theCabooseExit;
            if (exitBackwards) {
            categoryRequired = 'Backwards 180';
            theCabooseExit = pickRandomTrick(categoryRequired);
            } else {
            categoryRequired = 'Ground Cross';
            theCabooseExit = pickRandomTrick(categoryRequired);
            }
            theNextSelection = theCabooseExit;
            console.log('C-F1-2-2: ',theCabooseExit.na, ' added after the ~Caboose~ as sequence is not over yet.');
            isValidExit = true;
            }
        } else {
            console.log('C-F1-3: ',theNextSelection.na,' did not require no adjustment.');
            isValidExit = true;
        }
        return isValidExit;
    }

    function checkReleaseExit() {
        isValidExit = false;

        possibleExits = [
            { 'name': '', 'exit': ' >'},
            { 'name': '', 'exit': ' > Open >'},
            { 'name': ' (Swing out)', 'exit': ' > Swing <B> <SS> >'},
            { 'name': ' (Swing out on other side)', 'exit': ' > Swing <B> <OS> >'},
            { 'name': ' (Swing, Swing out)', 'exit': ' > Swing <B> <OS> > Swing <W> >'}
        ];

        if (!theNextSelection.na.includes('EB Swing Release') && theNextSelection.sk.endsWith(' > Open >')) {
            console.log('R-F3-1: ',theNextSelection.na, ' ends with an Open (and is NOT an EB Swing Release)');
            theNextSelection.sk = theNextSelection.sk.replace(/ > Open >$/, '');
        
            let randomExit;
            if (theNextSelection.na.includes('Handle Pass') && !theNextSelection.na.includes('Release')) {
                console.log('R-F3-2: ',theNextSelection.na, ' is a ~Pass~ but NOT ~Mic~');
                randomExit = possibleExits[0];
            } else {
                randomExit = pickRandomOption(possibleExits);
                console.log('R-F3-3: ',theNextSelection.na, ' is a standard ~Mic~, (and is NOT a ~Handle Pass~ or ~EB Swing~)');
            }

            if (randomExit.exit.includes('<SS>') && theNextSelection.na.includes('Toad Swing')) {
                console.log('R-F3-4: ',theNextSelection.na, ' is starts with a ~Toad Swing~ and ends (randomly) with a SS Box Swing');
                let toadSubstring = theNextSelection.na.split(' Swing <B>')[0];
                randomExit.exit = randomExit.exit.replace('Swing', toadSubstring);
            }

        theNextSelection.na += randomExit.name;
        theNextSelection.sk += randomExit.exit;
        console.log('R-F3-5: ',theNextSelection.na, ' exit adjusted.');
        isValidExit = true;
        }
        return isValidExit;
    }
 
    function checkWrapExit() {
        isValidExit = false;

        if (theNextSelection.na.includes('180')) {
            console.log('W-F1-1: ',theNextSelection.na ,' is a ~Wrap 180~');
            if (theFinalSelection.length < theSelectionCounter) {
                console.log('W-F1-2: ',theNextSelection.na ,' added to theFinalSelection. BW 180 required. Choosing now...');
                theFinalSelection.push(theNextSelection);
                categoryRequired = 'Backwards 180';
                let theNextBWSelection = pickRandomTrick(categoryRequired);
                if (theNextBWSelection) {
                    theNextSelection = theNextBWSelection;
                    console.log('W-F1-3: theNextBWSelection assigned to ',theNextSelection.na);
                }
            }
            console.log('W-F1-3: Valid exit found!');
            isValidExit = true;
        } else {
            console.log('W-F1-3: No rule(s) applied to this trick, no adjustment made.');
            isValidExit = true;
        }
        return isValidExit;
    }

    function checkDirectionChangeExit() {
        isValidExit = false;

        if (theFinalSelection.length < theSelectionCounter) {

            if (!theNextSelection.na.includes('Backwards') && !theNextSelection.na.includes('BW') && !theNextSelection.na.includes('360') && !theNextSelection.na.includes('Turn')) {
                console.log('D-F-1: ',theNextSelection.na,' is a FW 180 / Stall. Next trick MUST be a BW 180 / Stall...');
                console.log('D-F-2-1: Sequence has not ended. Choosing BW 180 / Stall...')
                categoryRequired = 'D';
                nameFilter = 'Backwards';
                let theNextBWSelection = pickRandomTrick(categoryRequired, nameFilter);
                if (theNextBWSelection) {
                    theNextSelection = theNextBWSelection;
                    console.log('D-F-2-1: ',theNextBWSelection.na,' is a BW 180 / Stall. Added to theFinalSelection as well.');
                } else {
                    let defaultTurn = {
                        "na": "Backwards 180",
                        "sk": "> <BW> Open 180 >",
                        "vi": 833936808,
                        "ca": "D",
                        "c1": "Backwards 180"
                    };
                    console.log('D-F-2-2: No suitable BW 180 / Stall found. defaultTurn used instead.');
                    theNextSelection = defaultTurn;
                }
                isValidExit = true; 
            } else {
                console.log('D-F-3:', theNextSelection.na, ' is BW 180 / Stall. Next trick can be anything.');
            }
        } else {
            console.log('D-F-4: theSelectionCounter does not require another trick. BW 180 / Stall not needed.');
        }
        return isValidExit;
    }

    function checkComboExit() {
        console.log('CO-F-1: checkComboExit intiated.');
        isValidExit = false; 
        let possibleCategories = ['C', 'D', 'R', 'W'];
        const firstComboCategory = theNextSelection.ca; 
        const secondComboCategory = theNextSelection.cb.charAt(1);
    
        possibleCategories = possibleCategories.filter(category => category !== firstComboCategory);
    
        if (firstComboCategory !== secondComboCategory) {
            console.log('CO-F-2: ',secondComboCategory, ' is not the same as ', firstComboCategory);
            isValidExit = false;
    
            if (secondComboCategory === 'C') {
                console.log('CO-F-3: Calling checkCrossExit as Combo ends with a Cross');
                isValidExit = checkCrossExit();
            } else if (secondComboCategory === 'D') {
                console.log('CO-F-4: Calling checkDirectionChangeExit as Combo ends with a FW 180 / Stall');
                isValidExit = checkDirectionChangeExit(); 
            } else if (secondComboCategory === 'R') {
                console.log('CO-F-5: Calling checkReleaseExit as Combo ends with a Release');
                isValidExit = checkReleaseExit(); 
            } else if (secondComboCategory === 'W') {
                console.log('CO-F-6: Calling checkWrapExit as Combo ends with a Wrap');
                isValidExit = checkWrapExit(); 
            } else {
                console.log('CO-F-7: Error: Invalid/unrecognised category in the Combo. No adjustment made. EDGE CASE');
                isValidExit = true;
            }
            return isValidExit;
        } else {
            console.log('CO-F-8: Both trick categories are the same. No adjustment needed.');
            return isValidExit; 
        }
    }
    

    while (theFinalSelection.length < theSelectionCounter) {
        let suitableFound = false;

        while (!suitableFound) {
            theNextSelection = pickRandomTrick();

            if (!theNextSelection) {
                console.log("No valid selection found.");
                break;
            }
            if (theFinalSelection.length > 0) {
                let lastSkill = theFinalSelection[theFinalSelection.length - 1];
                if (lastSkill.vi === theNextSelection.vi) {
                    console.log("Duplicate found. Rechoosing...");
                    theNextSelection = pickRandomTrick();
                    continue; 
                } else {
                 thePreviousSelection = lastSkill;
                 console.log('thePreviousSelection is now ', thePreviousSelection.na);
                }
            }
            
            console.log('Appropriate theNextSelection chosen:', theNextSelection.na);

     switch (theNextSelection.ca) {
            
    case 'F':
    
    // Initialize footworkCounter only if it's not already set
    if (typeof footworkCounter === 'undefined') {
        if (theCategoryTypes.length === 1 && theCategoryTypes[0] === 'F') {
            footworkCounter = theSelectionCounter;
            if (footworkCounter % 2 !== 0) {
                footworkCounter += 1; 
            }
        } else {
            let maxFootwork = Math.floor(theSelectionCounter / 2); 
            footworkCounter = 2 * Math.floor(Math.random() * (maxFootwork / 2)) + 2; 
        }
        console.log(`Footwork counter set to ${footworkCounter}`);
    }

    categoryRequired = 'F';     
    while (footworkCounter > 0 && theFinalSelection.length < theSelectionCounter) {
       if (typeof theNextSelection.no !== 'string') {
            console.log(`Skipping ${theNextSelection.na}: 'no' property is missing or invalid.`);
            theNextSelection = pickRandomTrick(categoryRequired);
            continue;
        }

       let commaCount = (theNextSelection.no.match(/,/g) || []).length;
       let isOtherSide = Math.random() < 0.5;

       // Randomly choose between Method 1, 2 & 3
       let theOptions = ['M1', 'M2', 'M3'];
       let method = pickRandomOption(theOptions);
       console.log('Next method selected:', method);

      // Method 1: AA Patterns
      if (method === 'M1') {
        
        if (commaCount === 2 && !theNextSelection.na.includes('Side Raise')) {
            theFinalSelection.push(theNextSelection);

            let secondFootwork = Object.assign({}, theNextSelection);
            if (isOtherSide && !secondFootwork.na.includes('Side Straddle')) {
                secondFootwork.sk = secondFootwork.sk.replace(" > ", " <OS> > ");
                secondFootwork.na += ' (other side)';
                console.log(`Modified ${secondFootwork.na} to indicate other side.`);
            }
            theFinalSelection.push(secondFootwork);
            console.log(`${theNextSelection.na} with comma count 2 added twice as part of Footwork succession.`);
            footworkCounter -= 1;
        } else if (commaCount === 4) {
            theFinalSelection.push(theNextSelection);
            console.log(`${theNextSelection.na} with comma count 4 added once as part of Footwork succession.`);
            footworkCounter -= 2;
        } else {
                console.log(`Invalid comma count for ${theNextSelection.na}. Rechoosing...`);
                theNextSelection = pickRandomTrick(categoryRequired);
                continue;
       }

    // Method 2: ABAB Patterns
    } else if (method === 'M2' && commaCount === 2 && !theNextSelection.na.includes('Side Raise')) {
    let firstFootwork = Object.assign({}, theNextSelection); 
    let secondFootwork, secondCommaCount;

    do {
        secondFootwork = pickRandomTrick(categoryRequired); 
        secondCommaCount = secondFootwork.no && typeof secondFootwork.no === 'string' ? (secondFootwork.no.match(/,/g) || []).length : 0;
    } while (secondFootwork === firstFootwork || secondFootwork.ca !== 'F' || secondCommaCount !== 2);

    removeTheLastOpen(firstFootwork);
    removeTheLastOpen(secondFootwork);

    let isOtherSideForThird = Math.random() < 0.5;  
    if (isOtherSideForThird && !firstFootwork.na.includes('Side Straddle')) {
    let thirdFootwork = Object.assign({}, firstFootwork);
    thirdFootwork.sk = thirdFootwork.sk.replace(" > ", " <OS> > ");
    thirdFootwork.na += ' (other side)';
    console.log(`Modified ${thirdFootwork.na} to indicate other side for the third instance.`);

    theFinalSelection.push(firstFootwork, secondFootwork, thirdFootwork, secondFootwork);
    } else {
    theFinalSelection.push(firstFootwork, secondFootwork, firstFootwork, secondFootwork);
    }
    console.log(`Added ${firstFootwork.na} and ${secondFootwork.na} with variations.`);
    footworkCounter -= 4;

    // Method 3: ABAC Patterns
    }  else if (method === 'M3' && theNextSelection.na === 'Knee Raise' && commaCount === 2) {
    let firstFootwork = Object.assign({}, theNextSelection); 
    let secondFootwork, secondCommaCount;
    let thirdFootwork, thirdCommaCount;
      
    do {
        secondFootwork = pickRandomTrick(categoryRequired);
        secondCommaCount = (secondFootwork.no.match(/,/g) || []).length; 
    } while (secondFootwork === firstFootwork || secondFootwork.ca !== 'F' || secondCommaCount !== 2);

    do {
        thirdFootwork = pickRandomTrick(categoryRequired); 
        thirdCommaCount = (thirdFootwork.no.match(/,/g) || []).length; 
    } while (thirdFootwork === firstFootwork || thirdFootwork === secondFootwork || thirdFootwork.ca !== 'F' || thirdCommaCount !== 2);

    removeTheLastOpen(firstFootwork);
    removeTheLastOpen(secondFootwork);
    removeTheLastOpen(thirdFootwork);

    theFinalSelection.push(firstFootwork, secondFootwork, firstFootwork, thirdFootwork);
    console.log(`Added ${firstFootwork.na}, ${secondFootwork.na}, and ${thirdFootwork.na} in ABAC succession.`);
    footworkCounter -= 4;
    } else {
    console.log(`Invalid skill for selected method or comma count for ${theNextSelection.na}. Rechoosing...`);
    theNextSelection = pickRandomTrick(categoryRequired);
    continue;
    }

        if (footworkCounter > 0) {
        let newFootworkSelection;
        do {
            newFootworkSelection = pickRandomTrick(categoryRequired);
        } while (newFootworkSelection.ca !== 'F' || newFootworkSelection === theNextSelection);
        theNextSelection = newFootworkSelection; 
     }
   }

   suitableFound = (footworkCounter <= 0 || theFinalSelection.length >= theSelectionCounter);
   thePreviousSelection = theNextSelection; 
   break;

           
    case 'C':

    console.log('Case C initiated for ', theNextSelection);

    function checkCrossEntry() {
        isValidEntry = false;

        if ((thePreviousSelection.sk.endsWith('> EB Swing >'))
           || ((thePreviousSelection.sk.endsWith('> Swing <B> <SS> >') || thePreviousSelection.sk.endsWith('> Swing <B> <OS> >')) && !theNextSelection.na.includes('Leg Over')) 
           || (thePreviousSelection.sk.endsWith('> Swing <W> >') && ((theNextSelection.na.includes('Leg Over') || theNextSelection.na.includes('Dive') || theNextSelection.p1 === 'Back Cross')))) {
            console.log('C-F2-1: ', thePreviousSelection.na, ' ends with EB Swing / Box Swing but ', theNextSelection.na ,' is not a ~Leg Over~ / Wrist Swing and theNextSelection is a ~Leg Over~ or ~Dive~ or ~Back Cross~.');
            isValidEntry = true;
        } else if ((thePreviousSelection.sk.endsWith('> Release >') || thePreviousSelection.sk.endsWith(' <DR> >')) && !theNextSelection.na.includes('Leg Over')) {
            console.log('C-F2-2: ',thePreviousSelection.na,' ends with ~Release~ or ~DR~ and ', theNextSelection.na ,' is not a ~Leg Over~.');
            possibleExits = [
                {"na": "", "sk": " > Open >"},
                {"na": "", "sk": " "}
            ];
            randomExit = pickRandomOption(possibleExits);
            thePreviousSelection.na += randomExit.na;
            thePreviousSelection.sk += randomExit.sk;
            isValidEntry = true;
        } else if (thePreviousSelection.sk.endsWith('> Open >') && theNextSelection.sk.startsWith('> Open >')) {
            console.log('C-F2-3: ',thePreviousSelection.na,' and ', theNextSelection.na,' end/start with an Open');
            thePreviousSelection.sk = thePreviousSelection.sk.replace(' > Open >',' >');
            isValidEntry = true;
        } else if (thePreviousSelection.sk.endsWith(' Toad Gogo >')) {
            console.log('C-F2-4: ',thePreviousSelection.na,' ends with a ~Gogo~');
            if ((!theNextSelection.na.includes('Dive')) && (!theNextSelection.p1 === 'Back Cross')) {
                console.log('C-F2-4-1: ',theNextSelection.na,' is a ~Dive~ or ~Back Cross~');
                } else {
                console.log('C-F2-4-1: ',theNextSelection.na,' is NOT a ~Dive~ or ~Back Cross~');
                adjustedExit = ' Open >';
                thePreviousSelection.sk += adjustedExit;
            }
            isValidEntry = true;
        } else if ((theNextSelection.sk.startsWith('> Toad Swing <W>')) || (theNextSelection.sk.startsWith('> Inverse Toad Swing <W>'))) {
            console.log('C-F2-5: ',theNextSelection.na, ' starts with a Leg Wrist Swing.');
            adjustedExit = ' Open >';
            thePreviousSelection.sk += adjustedExit;
            isValidEntry = true;
        } else if (((theNextSelection.sk.startsWith('> T-Toad >')) || (theNextSelection.sk.startsWith('> Inverse T-Toad >'))) 
            && ((!thePreviousSelection.sk.endsWith('> Open >')) && (!thePreviousSelection.sk.endsWith('> Cross >')) && (!thePreviousSelection.sk.endsWith('Swing >')))) {
            console.log('C-F2-6: ',theNextSelection.na,' is a ~Tucked Cross~ and ',thePreviousSelection.na,' does NOT end with an Open or Cross or Swing');
            possibleExits = [
                {"na": "", "sk": " Open >"},
                {"na": " (Swing out)", "sk": " Swing <B> >"}
               ]; 
            theTuckPre = pickRandomOption(possibleExits);
            thePreviousSelection.sk += theTuckPre
            isValidEntry = true;
        } else if (theNextSelection.na.includes('AS Toad') && !thePreviousSelection.sk.endsWith('> Open >')) {
            console.log('C-F2-7: ',theNextSelection.na,' is an ~AS Toad~ and ',thePreviousSelection.na,' does NOT end with an Open');
            adjustedExit = ' Open >';
            thePreviousSelection += adjustedExit;
            isValidEntry = true;
        } else if (thePreviousSelection.c1 === 'Leg Cross' && theNextSelection.na === 'Cross') {
            console.log('C-F2-8: ',thePreviousSelection.na,' is a ~Leg Cross~ and ',theNextSelection.na,' is a Basic Cross');
            possibleExits = [
            {"na": "", "sk": " Open >"},
            {"na": " (Swing out)", "sk": " Swing >"}
            ];
            randomExit = pickRandomOption(possibleExits);
            thePreviousSelection.na += randomExit.na;
            thePreviousSelection.sk += randomExit.sk;
            isValidEntry = true;
        } else if ((thePreviousSelection.c1 === 'Leg Cross' && theNextSelection.c1 === 'Leg Cross')) {
            console.log('C-F2-9-1: ',thePreviousSelection.na,' and ',theNextSelection.na,' are BOTH Leg Crosses');
            if (thePreviousSelection.no.toLowerCase().includes('t') && theNextSelection.no.toLowerCase().includes('t')) {
                console.log('C-F2-9-2: ',thePreviousSelection.na,' and ',theNextSelection.na,' BOTH contain a ~Toad~ placement');
                possibleExits = [
                    {"na": "", "sk": " Open >"},
                    {"na": " (Toad Swing to...)", "sk": " Toad Swing >"}
                    ];
            } else if (thePreviousSelection.no.toLowerCase().includes('i') && theNextSelection.no.toLowerCase().includes('i')) {
                console.log('C-F2-9-3: ',thePreviousSelection.na,' and ',theNextSelection.na,' BOTH contain a ~Inv Toad~ placement');
                possibleExits = [
                    {"na": "", "sk": " Open >"},
                    {"na": " (Inverse Toad Swing to...)", "sk": " Inverse Toad Swing >"}
                    ];
            } else if (thePreviousSelection.no.toLowerCase().includes('e') && theNextSelection.no.toLowerCase().includes('e')) {
                console.log('C-F2-9-5: ',thePreviousSelection.na,' and ',theNextSelection.na,' BOTH contain an ~EB~ placement');
                possibleExits = [
                    {"na": "", "sk": " Open >"},
                    {"na": " (EB Swing to...)", "sk": " EB Swing >"}
                    ];
            } else if (thePreviousSelection.no.toLowerCase().includes('n') && theNextSelection.no.toLowerCase().includes('n')) {
                console.log('C-F2-9-5: ',thePreviousSelection.na,' and ',theNextSelection.na,' BOTH contain an ~AS~ placement');
                possibleExits = [
                    {"na": "", "sk": " Open >"},
                    {"na": " (AS Swing to...)", "sk": " AS Swing >"}
                    ];
            } else {
                console.log('C-F2-9-6: ',thePreviousSelection.na,' and ',theNextSelection.na,'  do NOT have matching t/i/e/n placements');
                possibleExits = [
                    {"na": "", "sk": " Open >"}
                    ];
            }
        
        randomExit = pickRandomOption(possibleExits);
        thePreviousSelection.na += randomExit.na;
        thePreviousSelection.sk += randomExit.sk;
        isValidEntry = true;
        } 
        return isValidEntry;
    }

    let attemptCounter = 0;
    const maxAttempts = 50; 
    while (!suitableFound && attemptCounter < maxAttempts) {
        attemptCounter++;
        console.log(`C-fallback-1: Attempt ${attemptCounter}: Trying to find a suitable trick for category 'C'...`);

        if (theFinalSelection.length === 0) {
            console.log('C-if-1-1: ',theNextSelection.na,' is the first trick in the sequence. Checking its exit only...');

            if (theNextSelection.cb) {
                console.log('C-if-1-2:',theNextSelection.na,' is a Combo. Calling checkComboExit() function...');
                isValidExit = checkComboExit();
            } else {
                console.log('C-if-1-3:',theNextSelection.na,' is NOT a Combo. Calling checkCrossExit() function...');
                isValidExit = checkCrossExit();
            }
            
            if (isValidExit) {
                theFinalSelection.push(theNextSelection);
                console.log('C-if-1-4: ',theNextSelection.na,' exit is valid. Added to theFinalSelection.');
                suitableFound = true;
                break;
            }
        }

        isSuitable = false;
        
        if (theFinalSelection.length > 0) {
            console.log('C-if-2-1: ',theNextSelection.na,' is NOT the first trick in the sequence. Checking its entry AND exit...');
            console.log('C-if-2-2: ',thePreviousSelection.na,' is thePreviousSelection.');

            isValidExit = false;
            isValidEntry = false;

            if (theNextSelection.cb) {
                console.log('C-if-2-3:',theNextSelection.na,' is a Combo. Calling checkComboExit() function...');
                isValidExit = checkComboExit();
            } else {
                console.log('C-if-2-4:',theNextSelection.na,' is NOT a Combo. Calling checkCrossExit() function...');
                isValidExit = checkCrossExit();
            }

            console.log('C-if-2-5: checkCrossEntry() function called.');
            isValidEntry = checkCrossEntry();

            if (isValidExit && isValidEntry) {
                console.log('C-if-2-6: isValidExit & isValidEntry both returned true.');
                isSuitable = true;
            }
        }

        if (isSuitable) {
            theFinalSelection.push(theNextSelection);
            console.log('C-end-1: ',theNextSelection.na,' added to theFinaSelection.');
            suitableFound = true; 
        } else {
            theFinalSelection.push(theNextSelection);
            console.log('C-end-2-1: ',theNextSelection.na, 'added to theFinalSelection but DID NOT meet any if statement in the loop...');
            console.log('C-end-2-2: EDGE CASE FOUND FOR ',theNextSelection.na);    
            suitableFound = true; 
        }
    }

    if (attemptCounter >= maxAttempts) {
        console.log("C-fallback-2: Max attempts reached, breaking out of the loop to prevent an infinite loop.");
        let backupTrick = {
            "na": "Basic Bounce",
            "sk": "> Open > Open >",
            "ca": "C",
            "c1": "Foundational",
            "vi": 833099743,
            "no": "O, O,"
            };
        theFinalSelection.push(backupTrick);
    }
    break;
           
    case 'D':

    console.log('Case D initiated for ', theNextSelection);

    if (theFinalSelection.length === 0) {
        theFinalSelection.push(theNextSelection);
        console.log('D-start-1: ',theNextSelection.na,' is the first trick in the sequence - automatically accepted!');
        isNeeded = checkDirectionChangeExit(); // isNeeded == isValidExit (renamed for readability)
        if (isNeeded) {
        theFinalSelection.push(theNextSelection);
        console.log('D-start-2: isNeeded returned true. BW 180/Stall was needed. Added to theFinalSelection.');
        } else {
        console.log('D-start-3: isNeeded returned false. BW 180/Stall was NOT needed.');
        }
        suitableFound = true;
        break;
    } 
    
    if (theNextSelection.na.includes('Backwards') || theNextSelection.na.includes('BW')) {
        console.log('D-if-1-1: ', theNextSelection.na, ' IS a BW ~D~. Rechoosing...');
        let forwardsTurnFound = false;
        while (!forwardsTurnFound) {
            categoryRequired = 'D';
            let theReselection = pickRandomTrick(categoryRequired);
            if (theReselection && !theReselection.na.includes('Backwards') && !theReselection.na.includes('BW')) {
                console.log('D-if-1-2: ', theReselection.na, ' IS a FW ~D~.');
                theNextSelection = theReselection;
                forwardsTurnFound = true;
            } else {
                console.log('D-if-1-3: The reselected trick is still a BW ~D~. Rechoosing...');
            }
        }
        theFinalSelection.push(theNextSelection);
        console.log('D-if-2: ', theNextSelection.na, ' added to theFinalSelection.');
    } else {
        console.log('D-if-3: ', theNextSelection.na, ' is NOT a BW ~D~. Added to theFinalSelection');
        theFinalSelection.push(theNextSelection);
        console.log('D-if-4-1: Checking if we need another ~D~ trick to ensure jumper is forwards...');
        isNeeded = checkDirectionChangeExit(); // isNeeded == isValidExit (renamed for readability)
        if (isNeeded) {
            theFinalSelection.push(theNextSelection);
            console.log('D-if-4-2: isNeeded returned true. BW 180/Stall was needed. Added to theFinalSelection.');
        } else {
            console.log('D-if-4-3: isNeeded returned false. BW 180/Stall was NOT needed.');
        }
        suitableFound = true;
    }

    break;
    
    case 'R':

    console.log('Case R initiated for ', theNextSelection);

    let releaseValidated = false;
    let isTheFirst = false;

    function validateRelease(isTheFirst) {
        releaseValidated = false;

        if (theNextSelection.cb) {
            console.log('R-F1-1:',theNextSelection.na,' is a Combo. Calling checkComboExit() function...');
            isValidExit = checkComboExit();
            if (isValidExit) {
                console.log('R-F1-2: Exit checked and adjusted (where necessary)');
                isValidComboExit = true;
            }
        }

        if (theNextSelection.na.includes('Floater')) {
            releaseValidated = true;
            console.log('R-F1-3: Release is a ~Floater~. Release is valid!');
        } else {

        if (!isTheFirst) {
            console.log('R-F1-4: ',theNextSelection.na,' is NOT the first trick in the sequence so can call validateEntry().');
            checkReleaseEntry();
            } 
            
            if (!isValidComboExit) {
                console.log('R-F1-5: Calling validateExit() because ',theNextSelection.na,' is NOT a Combo...');
                isValidExit = checkReleaseExit();
                if (isValidExit) {
                    console.log('R-F1-6: ',theNextSelection.na,' exit modified. Release now fully valid!');
                    releaseValidated = true;
                } else {
                    console.log('R-F1-7: ',theNextSelection.na,' exit already modified by checkComboExit(). No adjustment made here. Release now fully valid!');
                    releaseValidated = true;
                }
            }  
        }
        return releaseValidated;
    }

    function checkReleaseEntry() {
        isValidEntry = false;

        if (theNextSelection.na.includes('Hold') && ((thePreviousSelection.sk.endsWith('> Swing <B> <OS> >')) || thePreviousSelection.sk.endsWith('> Swing <B> <SS> >'))) {
             console.log('R-F2-1: ',theNextSelection.na,' is a ~Hold~ and ',thePreviousSelection.na,' ends with a Box Swing');

            if (theNextSelection.na.includes('Leg Over') || theNextSelection.na.includes('Dive')) {
                console.log('R-F2-2: ',theNextSelection.na,' is a ~Leg Over~ or ~Dive~, so', thePreviousSelection.na,' ending adjusted.');
                adjustedExit = ' Swing <W> >';
                thePreviousSelection.sk += adjustedExit;
                isValidEntry = true;
            } else if (theNextSelection.na.includes('EB') && !theNextSelection.na.includes('Dive')) {
                console.log('R-F2-3: ',theNextSelection.na,' is an ~EB Over~ but NOT a ~Dive~, so', thePreviousSelection.na,' ending adjusted.');
                adjustedExit = ' Swing <OS> >';
                thePreviousSelection.sk += adjustedExit;
                isValidEntry = true; 
            } else if (theNextSelection.na.includes('Toad') && !theNextSelection.na.includes('EB')) {
                console.log('R-F2-4: ',theNextSelection.na,' is a ~Toad~ but NOT an ~EB~, so', thePreviousSelection.na,' ending NOT adjusted.');
                isValidEntry = true; 
            }
            console.log('R-F2-5: ',thePreviousSelection.na, ' adjusted to fit with the entry of ',theNextSelection.na);
        }
        return isValidEntry;
    }

    if (theFinalSelection.length === 0) {
        console.log('R-start-1: ',theNextSelection.na,' is the first trick in the sequence.');
        isTheFirst = true;
        releaseValidated = false;
        validateRelease(isTheFirst);
        if (releaseValidated) {
                theFinalSelection.push(theNextSelection);
                console.log('R-start-2:', theNextSelection.na,' added to theFinalSelection.');
                suitableFound = true;
        }
        break; 
    }

    isSuitable = false;

    if (theFinalSelection.length > 0) {
        console.log('R-if-1: ',theNextSelection.na,' is NOT the first trick in the sequence.');
        isTheFirst = false; 
        validateRelease(isTheFirst);
        if (releaseValidated) {
            isSuitable = true;
        }
    }

    if (isSuitable) {
        theFinalSelection.push(theNextSelection);
        console.log('R-end-1: ', theNextSelection.na, ' added to theFinalSelection.');
        suitableFound = true;
    }
    break;

    case 'S':
        theFinalSelection.push(theNextSelection);
        console.log(theNextSelection.na, ' automatically added to theFinalSelection.');
        suitableFound = true;
    break;
       
    case 'W':

    console.log('Case W initiated for ', theNextSelection);

    if (theFinalSelection.length > 0) {
        console.log('W-if-1-1: ',theNextSelection.na,' is NOT the first trick in the sequence. Checking entry...');
        if (((theNextSelection.sk.startsWith('> Toad Swing >') 
            || theNextSelection.sk.startsWith('> Inverse Toad Swing >') 
            || theNextSelection.sk.startsWith('> Swing <B> >')))
            && (thePreviousSelection.sk.endsWith('> Swing <B> <SS> >')
            || thePreviousSelection.sk.endsWith('> Swing <B> <OS> >'))) {
                console.log('W-if-1-2: ',theNextSelection.na,' & thePreviousSelection both start/end with ~Box Swings~ back-to-back.');
                adjustedExit = ' Swing <W> >';
                thePreviousSelection.sk += adjustedExit;
        } if (((theNextSelection.sk.startsWith('> Leg Over Swing >')
            || theNextSelection.sk.startsWith('> Inverse Leg Over Swing >')
            || theNextSelection.sk.startsWith('> Swing <W> >'))) 
            && thePreviousSelection.sk.endsWith('> Swing <W> >')) {
                console.log('W-if-1-3: ',theNextSelection.na,' & thePreviousSelection both start/end with ~Wrist Swings~ back-to-back.');
            adjustedExit = ' Swing <B> >';
            thePreviousSelection.sk += adjustedExit;
        }
    } 

    console.log('W-if-2-1: Checking wrap exit (regardless of if isFirstTrick for ',theNextSelection.na);
    isValidExit = false;

    if (theNextSelection.cb) {
            console.log('W-if-2-2:',theNextSelection.na,' is a Combo. Calling checkComboExit() function...');
            isValidExit = checkComboExit();
    } else {
        console.log('W-if-2-3:',theNextSelection.na,' is NOT a Combo. Calling checkWrapExit() function...');
        isValidExit = checkWrapExit();
    }

    if (isValidExit) {
        console.log('W-end-1: ',theNextSelection.na,' fully valid, adding to theFinalSelection.')
        theFinalSelection.push(theNextSelection);
        suitableFound = true;  
    } else {
        console.log('W-end-2: ',theNextSelection.na,' NOT valid, adding to theFinalSelection anyway. EDGE CASE.')
        suitableFound = true; 
    }

    break;

           
    case 'M':
    // For now, automatically reject any Multiple skill and rechoose
    break;

            default:
                console.log(`Unexpected category: ${theNextSelection.ca}`);
                defaultCaseCounter++;
                if (defaultCaseCounter >= 3) {
                    console.log("Default case reached too many times. Exiting...");
                    return theFinalSelection; 
                }
                break;
            }
        }
    } 
    return theFinalSelection;
}FW ~360~ or  class="option-very-disable style="display:none;jsonDCDC
